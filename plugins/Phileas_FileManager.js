//=============================================================================
// Phileas_FileManager.js
//=============================================================================
// [Update History]
// 2025.February.16 Ver1.0.0 First Release
// 2025.February.17 Ver1.0.1 Added read/write file methods
// 2025.March.01 Ver1.0.2 Fixed read/write json file methods
// 2025.April.23 Ver1.0.3 When writing a file, non-existent folders are created from its path
// 2025.June.09 Ver1.1.0 Switched web storage from localStorage to IndexedDB (Web)

/*:
 * @target MZ
 * @plugindesc 1.1.0 Cross-platform file manager
 * @author Phileas
 * 
 * @param updateStamp
 * @text Update files stamp at startup
 * @type boolean
 * @desc Disable this before deploying the game
 * @default true
 * 
 * 
 * @help
 * 
 * This is an auxiliary plugin that allows to work with files in any environment.
 * 
 * The plugin provides the following methods that can be used in other
 * plugins or scripts:
 * - Phileas_FileManager.fileExistsSync(path) - synchronously checks for file availability
 * - Phileas_FileManager.getFilesInDirectory(path) - synchronously returns a list of files
 *   in the specified directory, including nested directories of any level
 * - Phileas_FileManager.readFile(path) - asynchronously returns the contents of the file
 * - Phileas_FileManager.readJsonFile(path) - asynchronously returns the deserialized contents
 *   of the JSON file
 * - Phileas_FileManager.writeFile(path, data) - asynchronously saves the specified
 *   data to a file
 * - Phileas_FileManager.writeJsonFile(path, data) - serializes the specified data in JSON
 *   and asynchronously saves it to a file
 * - Phileas_FileManager.downloadFile(path) - downloads a file from the local storage.
 *   This method only works in a web environment and on mobile platforms.
 *   The method must be called after saving the file using Phileas_FileManager.writeFile
 *   or Phileas_FileManager.writeJsonFile
 * - Phileas_FileManager.importSaveFile - imports the save file to and on Android
 * 
 * The path in all methods is the path to the file/directory relative to the root of the game.
 * 
 * To save files on Android, you need to add this Java code
 * to Android Studio when building the apk:
 * https://github.com/Oleg-Olegovich/phileas-public-plugins/blob/master/android/Phileas_FileManager_WebInterface.java
 * 
 * Contact the author of the plugin if you need other methods or commands of the plugin.
 *
 * In order for the plugin to work in the browser and on mobile devices, it is necessary
 * the current data/FilesStamp.json file.
 * This file contains information about all the game files.
 * This file is automatically generated when the game starts, if enabled
 * the updateStamp parameter. This plugin parameter is recommended
 * disable it before deployment.
 * 
 * 
 * You can always write to the author if you need other features or even plugins.
 * Boosty: https://boosty.to/phileas
 * RPG Maker Web: https://forums.rpgmakerweb.com/index.php?members/phileas.176075/
 * RPG Maker Union: https://rpgmakerunion.ru/id/phileas
 * Email: olek.olegovich gmail.com
 * Telegram: olekolegovich
 * 
 *-----------------------------------------------------------------------------
 * [License]
 * This plugin is released under MIT license.
 * http://opensource.org/licenses/mit-license.php
 *
 * This means that you can freely use the plugin in non-commercial and commercial games and even edit it.
 * But be sure to include me in the credits!
 */

/*:ru
 * @target MZ
 * @plugindesc 1.1.0 Кроссплатформенный менеджер файлов
 * @author Phileas
 * 
 * @param updateStamp
 * @text Обновить штамп файлов при запуске
 * @type boolean
 * @desc Отключите перед деплоем игры
 * @default true
 * 
 * 
 * @help
 * 
 * Это вспомогательный плагин, который позволяет работать с файлами в любой среде.
 * 
 * Плагин предоставляет следующие методы, которые можно использовать в других
 * плагинах или в скриптах:
 * - Phileas_FileManager.fileExistsSync(path) - синхронно проверяет наличие файла
 * - Phileas_FileManager.getFilesInDirectory(path) - синхронно возвращает список файлов
 *   в указанной директории, включая вложенные директории любого уровня
 * - Phileas_FileManager.readFile(path) - асинхронно возвращает содержимое файла
 * - Phileas_FileManager.readJsonFile(path) - асинхронно возвращает десериализованное
 *   содержимое JSON-файла
 * - Phileas_FileManager.writeFile(path, data) - асинхронно сохраняет указанные
 *   данные в файл
 * - Phileas_FileManager.writeJsonFile(path, data) - сериализует указанные данные
 *   в JSON и асинхронно сохраняет их файл
 * - Phileas_FileManager.downloadFile(path) - скачивает файл из локального хранилища.
 *   Этот метод работает только в веб-среде и на мобильных платформах. Метод нужно
 *   вызывать после сохранения файла с помощью Phileas_FileManager.writeFile
 *   или Phileas_FileManager.writeJsonFile
 * - Phileas_FileManager.importSaveFile - импортирует файл сохранения в и на Android
 * 
 * path во всех методах - это путь к файлу/директории относительно корня игры.
 * 
 * Для сохранения файлов на Android, необходимо добавить этот Java-код в
 * Anroid Studio при сборке apk:
 * https://github.com/Oleg-Olegovich/phileas-public-plugins/blob/master/android/Phileas_FileManager_WebInterface.java
 * 
 * Обратитесь к автору плагина, если вам нужны другие методы или команды плагина.
 * 
 * Чтобы плагин работал в браузере и на мобильных устройствах, необходим
 * актуальный файл data/FilesStamp.json.
 * Этот файл содержит данные обо всех файлах игры.
 * Этот файл автоматически генерируется при запуске игры, если включён
 * параметр updateStamp. Этот параметр плагина рекомендуется
 * отключить перед деплоем.
 * 
 * 
 * Вы всегда можете написать автору, если вам нужны другие функции или даже плагины.
 * Boosty: https://boosty.to/phileas
 * RPG Maker Web: https://forums.rpgmakerweb.com/index.php?members/phileas.176075/
 * RPG Maker Union: https://rpgmakerunion.ru/id/phileas
 * Email: olek.olegovich gmail.com
 * Telegram: olekolegovich
 * 
 *-----------------------------------------------------------------------------
 * [License]
 * Этот плагин распространяется по лицензии MIT.
 * http://opensource.org/licenses/mit-license.php
 *
 * Это означает, что вы можете свободно использовать плагин в некоммерческих
 * и коммерческих играх и даже редактировать его.
 * Но обязательно укажите меня в титрах!
 * 
 */

"use strict";


function Phileas_FileManager() {
    throw new Error("This is a static class");
}

Phileas_FileManager._stampFile = "data/FilesStamp.json";
Phileas_FileManager._cache = {};

Phileas_FileManager._parameters = PluginManager.parameters("Phileas_FileManager");
Phileas_FileManager._updateRequired = Phileas_FileManager._parameters["updateStamp"] === "true";

Phileas_FileManager._openDb = function() {
    if (this._db) {
        return Promise.resolve(this._db);
    }
    
    return new Promise((resolve, reject) => {
        const req = indexedDB.open("RMMZ-Screenshots", 1);
        req.onupgradeneeded = e => {
            e.target.result.createObjectStore("files");
        };
        req.onsuccess = e => {
            this._db = e.target.result;
            resolve(this._db);
        };
        req.onerror = e => reject(e.target.error);
    });
};

Phileas_FileManager.writeFileWeb = function(path, data) {
    return this._openDb().then(db => new Promise((res, rej) => {
        const tx = db.transaction("files", "readwrite");
        tx.objectStore("files").put(data, path);
        tx.oncomplete = () => {
            console.log(`Saved file to IndexedDB: ${path}`);
            res();
        };
        tx.onerror = e => rej(e.target.error);
    }));
};

Phileas_FileManager.readFileWeb = function(path) {
    return this._openDb().then(db => new Promise((res, rej) => {
        const tx = db.transaction("files", "readonly");
        const req = tx.objectStore("files").get(path);
        req.onsuccess = () => {
            if (req.result != null) {
                res(req.result);
            } else {
                rej(new Error(`No entry for ${path}`));
            }
        };
        req.onerror = e => rej(e.target.error);
    }));
};

Phileas_FileManager.removeFileWeb = function(path) {
    return this._openDb().then(db => new Promise((res, rej) => {
        const tx = db.transaction("files", "readwrite");
        tx.objectStore("files").delete(path);
        tx.oncomplete = () => res();
        tx.onerror = e => rej(e.target.error);
    }));
};
// -----------------------------------------------

Phileas_FileManager.scanFileSystem = async function() {
    if (!Utils.isNwjs() || !Phileas_FileManager._updateRequired) {
        return;
    }

    const fs = require("fs");
    const path = require("path");
    const projectPath = path.dirname(process.mainModule.filename);
    const stampFile = path.join(projectPath, Phileas_FileManager._stampFile);

    function scanDir(dir) {
        let result = {};
        fs.readdirSync(dir).forEach(file => {
            const fullPath = path.join(dir, file);
            if (fs.statSync(fullPath).isDirectory()) {
                result[file] = scanDir(fullPath);
            } else {
                result[file] = true;
            }
        });

        return result;
    }

    const fileTree = scanDir(projectPath);
    fs.writeFileSync(stampFile, JSON.stringify(fileTree, null, 2));
    console.log("Phileas_FileManager: file scanning completed");
};

Phileas_FileManager.loadCache = async function() {
    if (Utils.isNwjs()) {
        return;
    }
 
    try {
        const response = await fetch(Phileas_FileManager._stampFile);

        if (!response.ok) {
            throw new Error(`${Phileas_FileManager._stampFile} not found`);
        }
 
        Object.assign(Phileas_FileManager._cache, await response.json());
        console.log("Phileas_FileManager: cache loaded");
    } catch (error) {
        console.error("Phileas_FileManager: cache loading failed", error);
    }
};

Phileas_FileManager.fileExistsSync = function(path) {
    if (Utils.isNwjs()) {
        const fs = require("fs");
        return fs.existsSync(path);
    }
 
    const parts = path.split("/");
    let current = Phileas_FileManager._cache;
    for (const part of parts) {
        if (!current[part]) {
            return false;
        }
 
        current = current[part];
    }
 
    return true;
};

Phileas_FileManager.getFilesInDirectoryNwJs = function(path) {
    const fs = require("fs");
    const pathModule = require("path");
    const projectPath = pathModule.dirname(process.mainModule.filename);
    const fullPath = pathModule.join(projectPath, path);
 
    function scanDir(dir) {
        let files = [];
        fs.readdirSync(dir).forEach(file => {
            const filePath = pathModule.join(dir, file);
            if (fs.statSync(filePath).isDirectory()) {
                files = files.concat(scanDir(filePath).map(subFile => file + "/" + subFile));
            } else {
                files.push(file);
            }
        });
        return files;
    }
 
    if (!fs.existsSync(fullPath) || !fs.statSync(fullPath).isDirectory()) {
        console.warn("Path not found:", path);
        return [];
    }
 
    return scanDir(fullPath);
};

Phileas_FileManager.getFilesInDirectoryWeb = function(path) {
    const parts = path.split("/").filter(Boolean);
    let current = Phileas_FileManager._cache;
    for (const part of parts) {
        if (!current[part]) {
            return [];
        }

        current = current[part];
    }
 
    function collectFiles(node, prefix = "") {
        let files = [];
        for (const key in node) {
            if (typeof node[key] === "object") {
                files = files.concat(collectFiles(node[key], prefix + key + "/"));
            } else {
                files.push(prefix + key);
            }
        }

        return files;
    }
 
    return collectFiles(current);
};

Phileas_FileManager.getFilesInDirectory = function(path) {
    return Utils.isNwjs()
        ? Phileas_FileManager.getFilesInDirectoryNwJs(path)
        : Phileas_FileManager.getFilesInDirectoryWeb(path);
};

Phileas_FileManager.readFileNwJs = async function(path) {
    const fs = require("fs");
    const pathModule = require("path");
    const fullPath = pathModule.join(pathModule.dirname(process.mainModule.filename), path);
    return fs.readFileSync(fullPath, "utf8");
};

Phileas_FileManager.readFile = async function(path) {
    return Utils.isNwjs()
        ? Phileas_FileManager.readFileNwJs(path)
        : Phileas_FileManager.readFileWeb(path);
};

Phileas_FileManager.readJsonFile = async function(path) {
    const data = await Phileas_FileManager.readFile(path);
    return data ? JSON.parse(data) : null;
};

Phileas_FileManager.writeFileNwJs = function(path, data) {
    const fs = require("fs");
    const pathModule = require("path");
    const fullPath = pathModule.join(pathModule.dirname(process.mainModule.filename), path);
    const dirPath = pathModule.dirname(fullPath);
    fs.mkdirSync(dirPath, { recursive: true });
    fs.writeFileSync(fullPath, data);
    console.log(`Saved file: ${path}`);
};

Phileas_FileManager.writeFile = async function(path, data) {
    if (Utils.isNwjs()) {
        Phileas_FileManager.writeFileNwJs(path, data);
    } else {
        await Phileas_FileManager.writeFileWeb(path, data);
    }
};

Phileas_FileManager.writeJsonFile = async function(path, data) {
    await Phileas_FileManager.writeFile(path, JSON.stringify(data));
};

Phileas_FileManager.downloadFile = async function(path) {
    if (Utils.isNwjs()) {
        console.warn("Phileas_FileManager.downloadFile is only for web builds");
        return;
    }
    try {
        const data = await Phileas_FileManager.readFileWeb(path);
        const blob = new Blob([data], { type: "application/json" });
        const fileName = path.split("/").pop();
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = fileName;
        a.style.display = "none";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        console.log(`📂 File downloaded: ${fileName}`);
    } catch (e) {
        console.error(`Download failed for ${path}`, e);
    }
};

Phileas_FileManager.importSaveFileWeb = function() {
    if (Utils.isNwjs()) {
        console.warn("Phileas_FileManager.importSaveFile is only for web builds");
        return;
    }
    const input = document.createElement("input");
    input.type = "file";
    input.accept = ".rpgsave";
    input.onchange = function(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
            const fileName = file.name;
            Phileas_FileManager.writeFileWeb(fileName, reader.result)
                .then(() => console.log(`📂 Save file imported: ${fileName} (stored in IndexedDB)`))
                .catch(err => console.error("Import failed", err));
        };
        reader.readAsDataURL(file);
    };
    input.click();
};

Phileas_FileManager.importSaveFile = function() {
    if (!navigator.userAgent.toLowerCase().includes("android")) {
        Phileas_FileManager.importSaveFileWeb();
    } else {
        Phileas_FileManager.importSaveFileAndroid();
    }
};

Phileas_FileManager.importSaveFileAndroid = function() {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = ".rpgsave";
    input.onchange = event => {
        const file = event.target.files[0];
        if (!file) {
            return;
        }

        const reader = new FileReader();
        reader.onload = () => {
            const base64Data = reader.result.split(",")[1];
            const fileName = file.name;

            if (window.Android && window.Android.saveBase64File) {
                window.Android.saveBase64File("save/" + fileName, base64Data);
                console.log(`📂 Save file imported to Android: ${fileName}`);
            } else {
                console.warn("Android API not found");
            }
        };
        reader.readAsDataURL(file);
    };

    input.click();
};

Phileas_FileManager.scanFileSystem();
Phileas_FileManager.loadCache();
